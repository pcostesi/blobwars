\documentclass[10pt,a4paper,notitlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{makeidx}
\usepackage{verbatim}

\usepackage[utf8]{inputenc}
\renewcommand\Authand{ y }
\author[1]{\rm Kevin J. Hanna}
\author[2]{\rm Pablo A. Costesich}
\affil[ ]{Alumnos de Ingeniería Informática}
\affil[ ]{Instituto Tecnológico de Buenos Aires}
\affil[ ]{Av. Madero 399, C.A.B.A., Argentina}
\affil[1]{\textit {khanna@alu.itba.edu.ar}}
\affil[2]{\textit {pcostesi@ieee.org}}


\newenvironment{definition}[1][Definición]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


%%%% PYGMENTS

\usepackage{fancyvrb}
\usepackage{color}

\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.50,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother

%%%%

%\email{khanna@alu.itba.edu.ar, pcostesi@ieee.org}

\title{Estrategia de resolución Minimax para Juegos de Suma Cero e Implementación para el juego \textit {BlobWars}}
\makeindex

\begin{document}
\maketitle
\begin{abstract}
Se presenta una introducción a la Teoría de Juegos y Juegos de Suma Cero. Estos son juegos de dos jugadores con turnos y un balance entre sus ganancias y pérdidas. La estrategia de resolución analizada en este informe es Minimax, un algoritmo de búsqueda en profundidad limitada, junto con la heurística de Poda Alfa-Beta. Se detalla la implementación y resultados prácticos.
\end{abstract}

\section{Introducción}
El Trabajo Práctico Especial de la cátedra de Estructuras de Datos y Algoritmos para el segundo cuatrimestre de 2012 propone la resolución del juego \textit{BlobWars} mediante el algoritmo Minimax, con y sin Poda Alfa-Beta, en el lenguaje de programación Java. La implementación del mismo debe contar con un modo visual y de lectura de tableros por archivo.


\subsection{BlobWars}
\textit{BlobWars} es un juego de dos jugadores por turnos en un tablero de 8x8. El objetivo es lograr la mayor cantidad de piezas sobre el tablero cuando alguno de los jugadores no pueda realizar nuevos movimientos.

Los posibles movimientos de una mancha (\textit{blob}) son siempre hacia casilleros vacíos y cumplen estas reglas:
\begin{itemize}
\item Los movimientos a distancia 1 mantienen la mancha de origen y generan una nueva del mismo color en el casillero de destino.
\item Los movimientos a distancia 2 desplazan la mancha al casillero de destino.
\item No pueden realizarse movimientos que no sean de distancia 1 o 2.
\end{itemize}

\begin{definition}
El conjunto $Manchas$ es equivalente a $\{-1, 0, 1\}$.
\end{definition}

\begin{definition}Un tablero es una matriz de $Manchas^{8x8}$.\end{definition}

\begin{definition}
Un punto es un par ordenado $\left\langle x, y\right\rangle \in Point$, donde $Point = Side \times Side$ y $Side = \{1, 2, 3, 4, 5, 6, 7, 8\}$.
\end{definition}

\begin{definition}
Se llama $Movements$ al siguiente conjunto:
\begin{equation}
Movements = Point \times Point
\end{equation}
\end{definition}

\begin{definition}
Un movimiento es un par ordenado $\left\langle inicio, destino\right\rangle \in Movements$.

Notación: $inicio \rightarrow destino$.
\end{definition}

\begin{definition}
Un movimiento válido para un jugador $p$ es un movimiento tal que el casillero de destino $d$ se encuentra libre (su valor es $0$) y el de inicio $s$ pertenece al jugador $p$ (su valor es $p$).

Notación: $v_{s \rightarrow d}(p)$
\end{definition}

\begin{definition}
Un casillero es el valor del tablero en un punto $p$.
\end{definition}

\begin{definition}
El casillero vacío es equivalente al valor $0$ en el tablero para el punto $p$.
\end{definition}

\begin{definition}
Una mancha es uno de los tres posibles estados $\in Manchas$ de una celda en un punto del tablero:
\begin{itemize}
\item[-1] \emph{Humano}: representado por la letra \textit{H}.
\item[0] \emph{Vacío}: representado por el espacio en blanco.
\item[1] \emph{Computadora}: representado por la letra \textit{C}.
\end{itemize}
\end{definition}

\begin{definition}
Se define distancia como:
\begin{equation}
    distancia(a, b) = \max(|a[x] - b[x]|, |a[y] - b[y]|)
\end{equation}

Donde $a$ y $b$ son los puntos en cuestión (tuplas de dos componentes $\mathbb{N}_{0}$), y $a[x]$ significa la componente $x$ de $a$.
\end{definition}

Adicionalmente, al final de cada movimiento la mancha en el destino \textit{infecta} a las vecinas según estas reglas:
\begin{itemize}
\item Si el casillero no se encuentra ocupado entonces se deja libre (no se altera).
\item Si el casillero se encuentra ocupado, la mancha presente en éste cambia al color de la mancha que infecta.
\end{itemize}

\begin{definition}
Aplicar un movimiento $m$ para un jugador $p$ a un tablero $b$ es aplicar las reglas de movimiento seguido de \textit{infectar} el casillero de destino. Se obtiene como resultado un tablero $b'$
\end{definition}

\begin{definition}
Un \textit{Tablero Terminal} es un tablero tal que para algún jugador no existen movimientos válidos para ninguna de sus manchas.
\begin{equation}
terminal(b) \Leftrightarrow \nexists m \in v_{s \rightarrow d}(p) \forall s, d \in Movements
\end{equation}
Donde $b$ es el tablero, $m$ un movimiento válido, $p$ un jugador y $s, d$ un movimiento.
\end{definition}

El juego termina cuando el tablero se completa o cuando el siguiente jugador no puede realizar un movimiento válido. Vale destacar que la primera condición implica la segunda.

\begin{definition}
Un turno es aplicar un movimiento válido $m$ para un jugador $p$ a un tablero $b$ y retornar el tablero resultante $b'$:
\begin{equation}
b' = turno(b, p, m)
\end{equation}
\end{definition}

\begin{definition}
Un \textit{ply} es un grupo de dos turnos que resulta de la aplicación recursiva de éstos para dos movimientos de jugadores alternados $m_p$ y $m'_{p'}$. En otras palabras:
\begin{equation}
ply(b, m_p, m_{p'}) = turno(turno(b, p, m_p), p', m_{p'})
\end{equation}
\end{definition}

\begin{definition}
Una partida es una serie finita $G$ de $n$ \textit{plies} tal que aplicar el último movimiento ($m^{n}_{s \rightarrow p}$) al tablero $b^{n - 1}$ resulta en un tablero terminal $b^{n}$; siendo $b^{n}$ el único tablero terminal en $G$.
\end{definition}

\section{Teoría de Juegos}
La Teoría de Juegos es un campo de la matemática que estudia mediante modelos sistemas definidos por reglas de acción con incentivos (juegos), y proporciona estrategias para llevar a cabo procesos de decisión. Es un campo de estudio estrechamente ligado a las ciencias del comportamiento y las ciencias que las utilizan, como ser: economía, biología, psicología, antropología y ciencias políticas. \cite[p. 1]{bbs}

El análisis de estos modelos implica una característica diferencial con respecto a otros campos como la Teoría de la Decisión en cuanto a que los actores en la Teoría de Juegos no tienen costos e incentivos prefijados, sino que varían con las acciones de sus oponentes. También asume que cada jugador elige según un criterio de \textit{fitness} o ventaja sobre su situación y no mediante un set de reglas independiente de la misma.

\begin{definition}
\textit{Fitness} es una función de probabilidad que toma un estado o conjunto de estímulos y devuelve una valoración escalar.
\end{definition}

Mediante el ingreso de estímulos a una constelación de entradas sensoriales, el actor racional genera una distribución estadística de probabilidad sobre distintos resultados con un \textit{fitness} asociado. \cite[p. 4]{bbs}

Los actores racionales escogen el resultado con mejor \textit{fitness} para un entorno determinado. Por lo tanto, si un actor es presentado con una opción $A$ de menor \textit{fitness} que $B$ escogerá $B$, y si es presentado con dicho $B$ de menor \textit{fitness} que $C$ entonces escogerá $C$ por sobre $A$ y $B$. Esto es llamado \textit{Consistencia de Elección}. \cite[p. 4]{bbs}

Este modelo se llama \textit{BCP} (\textit{beliefs, preferences, and constraints} \cite[p. 3]{bbs}), e implica que distintas decisiones afectan a los resultados de las valuaciones de \textit{fitness} con distinto grado de probabilidad. La Teoría de Juegos amplía el modelo para incorporar varios jugadores, y llama Estrategias a las \textit{BCP}. Los jugadores cuentan con el conocimiento de las reglas del juego, la naturaleza de sus contrincantes y estrategias disponibles. Para cada combinación de decisiones, para cada jugador, el juego le asigna una distribución de \textit{individual payoffs} (ganancias individuales). Con esto, la Teoría de Juegos logra predecir el comportamiento de cada jugador (al asumir que maximizará sus ganancias, al ser un actor racional). \cite[p. 8]{bbs}

Cabe destacar que el modelo no es aplicable a todo tipo de modelo válido, ya que en la práctica puede ocurrir que los actores no sean enteramente racionales, desconozcan parte de la información en un estado determinado o no sean consistentes en sus decisiones (por ejemplo, un animal que se vuelve adicto a un alimento determinado). \cite[p. 9 - 11, ]{bbs}

El problema más grave es que los actores racionales no respeten el Equilibrio de Nash. \cite{ram}

\subsection{Equilibrio de Nash}
El Equilibrio de Nash es un concepto de solución para un juego no cooperativo de dos o más jugadores, en donde todos ellos tienen conocimiento de las estrategias de equilibrio de los otros.

Si cada jugador ha elegido una estrategia y ningún jugador puede beneficiarse de un cambio de la misma cuando sus oponentes mantienen las de ellos, entonces se afirma que dicho conjunto de estrategias y sus ganancias individuales constituye un Equilibrio de Nash. \cite{osb}

Si un jugador $A$ tiene una estrategia dominante $S_A$ entonces existe un Equilibrio de Nash en donde $A$ juega $S_A$. En el caso de ser dos jugadores $A$ y $B$, existe un Equilibrio en donde $A$ juega $S_A$ y $B$ juega la mejor estrategia en respuesta a $S_A$ (puede no ser única). Si $S_A$ es una estrategia estrictamente dominante, $A$ juega $S_A$ en todo Equilibrio de Nash. Si ambos $A$ y $B$ tienen estrategias estricamente dominantes, existe un único Equilibrio de Nash en donde ambos jugadores juegan sus estrategias dominantes respectivas.

\subsection{Juegos de Suma Cero}

Los juegos de suma cero responden a la premisa básica de que las ganancias de un jugador se equiparan a la pérdida conjunta de los otros. Asume que existe un Equilibrio de Nash para un el mismo.

\begin{definition}
Una estrategia mixta es un tipo de estrategia donde un jugador escoge una columna de la matriz de ganancias del juego, mientras que el adversario escoge una fila. El conjunto de valores de dicha celda corresponde a las ganancias individuales para cada jugador.
\end{definition}

En el caso de los juegos de dos jugadores, un Equilibrio de Nash y Minimax devuelven la misma solución, donde constituye una estrategia mixta.

La resolución de los mismos puede llevarse a cabo mediante programación lineal, en donde dada una matriz de ganancias $M$, tal que el elemento $M_{i, j}$ es la ganancia individual cuando el jugador que minimiza escoge la estrategia en la fila $i$ y el que maximiza escoge la estrategia en la columna $j$, se debe encontrar un vector $u$ que cumpla:

Minimizar:
\begin{equation}
\sum_{i} u_i
\end{equation}

Tal que:
\begin{enumerate}
\item $u \geq 0$
\item $M u \geq 1$
\end{enumerate}
\cite{mic}

\section{Estructuras de Datos}
Para representar el árbol de juego se utilizó el propio stack de la máquina, y se aprovechó que la generación de tableros pudo ser realizada en un iterador. Esto supuso un ahorro en la implementación de estructuras caras como HashMaps y Listas Enlazadas. El ahorro no sólo fue espacial, sino que también temporal ya que no se necesitó crear gran cantidad de estructuras por cada nodo.

El tablero se representó mediante un array de objetos (referencias) a Player. Como el tablero tiene una altura fija, convertir los índices a posiciones y vice versa resultó sencillo y barato. Este tipo de representación se decidió por una cuestión de simplicidad (ahorrar la creación de Arrays anidados) y por la indirección que genera desreferenciar un objeto.

Point se implementó al principio como una clase con un patrón constructor que almacenaba las instancias de puntos anteriormente entregados para reducir el gasto de memoria. Al eliminar el uso de las listas como almacenamiento de tableros hijos, el uso de puntos en un momento dado en memoria se redujo y se volvió un simple contenedor de enteros.

Movement se implementó de forma tal en que ahorrara escribir $Pair\left<x, y\right>$. Es otro simple contenedor con un método que retorna la distancia entre los puntos del par.

Pair se implementó a modo de una tupla de dos objetos.



\section{Algoritmos}

Se implementaron dos familias de algoritmos, cada una con dos sub-categorías de heurística:
\begin{itemize}
\item TBID\{ABP, L\}Minimax: familia de algoritmos basados en tiempo, con \textit{Iterative Deepening}.
\item \{ABP, L\}Minimax: familia de algoritmos basados en nivel.
\end{itemize}

Las subcategorías de heurística corresponden a:
\begin{itemize}
\item ABP: \textit{Alpha Beta Pruning}, o Poda Alfa Beta. Elimina estados de búsqueda si la Ventana Alfa Beta se cierra.
\item L: \textit{Level}, Na\"ive Minimax basado en nivel (sin poda).
\end{itemize}

Si bien \textit{ABP} es similar a \textit{L} en su implementación, algunos detalles del lenguaje evitaron la reutilización directa del código. 

\subsection{Minimax (Na\"ive)}
<<<<<<< Updated upstream
  Minimax es un algoritmo que se utiliza para elegir el estado más conveniente al que se puede acceder.
  La conveniencia de cada estado, o puntaje, se define para cada problema en particular.
\subsection{Minimax con Poda Alfa-Beta}
||||||| merged common ancestors
\subsection{Minimax con Poda Alfa-Beta}
=======
Minimax se basa en el concepto de Equilibrio de Nash y Juegos de Suma Cero, donde \textit{max}imizar las ganancias significa \textit{min}imizar las pérdidas. Asume que cada jugador conoce las reglas del juego, las estrategias del oponente y que siempre actuará con la mejor disponible (ya que se encuentra en equilibrio).

La versión teórica de minimax no está determinada por nivel y evalúa hasta llegar a un tablero terminal. Sin embargo, el problema de generar tableros entra en la categoría NP, por lo que es imprático implementarlo de este modo.

El siguiente es un ejemplo (funcional) en Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{minimax}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{maximize}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{,} \PY{n}{is\PYZus{}computer}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}\PY{p}{:}
    \PY{l+s+sd}{""" Naïve minimax solver. """}
    \PY{c}{\PYZsh{} set the worst score possible for this player.}
    \PY{n}{score} \PY{o}{=} \PY{o}{-}\PY{n}{board}\PY{o}{.}\PY{n}{max\PYZus{}score} \PY{k}{if} \PY{n}{maximize} \PY{k}{else} \PY{n}{board}\PY{o}{.}\PY{n}{max\PYZus{}score}
    \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n+nb+bp}{None}
    \PY{k}{for} \PY{n}{child}\PY{p}{,} \PY{n}{move} \PY{o+ow}{in} \PY{n}{board}\PY{o}{.}\PY{n}{children}\PY{p}{(}\PY{n}{is\PYZus{}computer}\PY{o}{=}\PY{n}{is\PYZus{}computer}\PY{p}{)}\PY{p}{:}
        \PY{n}{local}\PY{p}{,} \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{minimax}\PY{p}{(}\PY{n}{child}\PY{p}{,} \PY{n}{level} \PY{o}{-} \PY{l+m+mi}{1}\PY{p}{,} \PY{o+ow}{not} \PY{n}{maximize}\PY{p}{,} \PY{o+ow}{not} \PY{n}{is\PYZus{}computer}\PY{p}{)}
        \PY{c}{\PYZsh{} update the score when a better local solution is found}
        \PY{k}{if} \PY{p}{(}\PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZlt{}} \PY{n}{local}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{o+ow}{not} \PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZgt{}} \PY{n}{local}\PY{p}{)}\PY{p}{:}
            \PY{n}{score} \PY{o}{=} \PY{n}{local}
            \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n}{move}
    \PY{c}{\PYZsh{} return the score when a terminal board has been reached}
    \PY{k}{if} \PY{n}{best\PYZus{}move} \PY{o+ow}{is} \PY{n+nb+bp}{None}\PY{p}{:}
        \PY{k}{return} \PY{n}{board}\PY{o}{.}\PY{n}{score}\PY{p}{,} \PY{n+nb+bp}{None}
    \PY{k}{return} \PY{n}{score}\PY{p}{,} \PY{n}{best\PYZus{}move}
\end{Verbatim}

Nota: el ejemplo, al igual que los subsiguientes, devuelve un \textit{score} con un movimiento.
\newpage

\subsection{Minimax (Level)}

Minimax Level (por Niveles) agrega una condición de corte al llegar a un nivel máximo dentro del árbol de llamados recursivo.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{minimax}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{level}\PY{p}{,} \PY{n}{maximize}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{,} \PY{n}{is\PYZus{}computer}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}\PY{p}{:}
    \PY{l+s+sd}{""" Naïve minimax solver, using level cut-off. """}
    \PY{k}{if} \PY{n}{level} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{board}\PY{o}{.}\PY{n}{score}\PY{p}{,} \PY{n+nb+bp}{None}
    \PY{c}{\PYZsh{} set the worst score possible for this player.}
    \PY{n}{score} \PY{o}{=} \PY{o}{-}\PY{n}{board}\PY{o}{.}\PY{n}{max\PYZus{}score} \PY{k}{if} \PY{n}{maximize} \PY{k}{else} \PY{n}{board}\PY{o}{.}\PY{n}{max\PYZus{}score}
    \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n+nb+bp}{None}
    \PY{k}{for} \PY{n}{child}\PY{p}{,} \PY{n}{move} \PY{o+ow}{in} \PY{n}{board}\PY{o}{.}\PY{n}{children}\PY{p}{(}\PY{n}{is\PYZus{}computer}\PY{o}{=}\PY{n}{is\PYZus{}computer}\PY{p}{)}\PY{p}{:}
        \PY{n}{local}\PY{p}{,} \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{minimax}\PY{p}{(}\PY{n}{child}\PY{p}{,} \PY{n}{level} \PY{o}{-} \PY{l+m+mi}{1}\PY{p}{,} \PY{o+ow}{not} \PY{n}{maximize}\PY{p}{,} \PY{o+ow}{not} \PY{n}{is\PYZus{}computer}\PY{p}{)}
        \PY{c}{\PYZsh{} update the score when a better local solution is found}
        \PY{k}{if} \PY{p}{(}\PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZlt{}} \PY{n}{local}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{o+ow}{not} \PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZgt{}} \PY{n}{local}\PY{p}{)}\PY{p}{:}
            \PY{n}{score} \PY{o}{=} \PY{n}{local}
            \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n}{move}
    \PY{k}{if} \PY{n}{best\PYZus{}move} \PY{o+ow}{is} \PY{n+nb+bp}{None}\PY{p}{:}
        \PY{k}{return} \PY{n}{board}\PY{o}{.}\PY{n}{score}\PY{p}{,} \PY{n+nb+bp}{None}
    \PY{k}{return} \PY{n}{score}\PY{p}{,} \PY{n}{best\PYZus{}move}
\end{Verbatim}
\newpage
\subsection{ABPMinimax (Minimax con Poda Alfa-Beta)}

La poda Alfa Beta es una modificación al algoritmo original de Minimax (pero se presenta en el informe como una versión de LMinimax modificada), de forma tal donde existe una \textit{Ventana Alfa Beta} de operación. Dicha ventana está formada por dos variables $\alpha$ y $\beta$, que corresponden respectivamente con el jugador que maximiza y el que minimiza.

La poda tiene la característica de devolver una solución con el mismo costo que Minimax, con la diferencia de no tener que explorar soluciones innecesarias.

El primer llamado se realiza bajo los valores normales de Minimax (el \textit{score} mínimo posible para el jugador que maximiza es asignado a $\alpha$ y el \textit{score} máximo posible para el jugador que minimiza es asignado a $\beta$).

Para la etapa de maximización, ABPMinimax explora las posibles soluciones y actualiza el valor de $\alpha$ de forma tal que quede con el máximo \textit{score} hasta el momento. La condición de corte (llamada \textit{Beta Cut-Off}) añadida es que si $score \geq \beta$ deja de explorar soluciones, ya que el valor excede la ventana $\alpha \leq score \leq \beta$.

Para la etapa de minimización, actualiza el valor de $\beta$ con el mínimo \textit{score} hasta el momento. La condición de corte (\textit{Alpha Cut-Off}) es: $score \leq \alpha$.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{alphabeta}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{level}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{maximize}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{,} \PY{n}{is\PYZus{}computer}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}\PY{p}{:}
    \PY{l+s+sd}{""" Minimax with Alpha-Beta Pruning. """}
    \PY{k}{if} \PY{n}{level} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{board}\PY{o}{.}\PY{n}{score}\PY{p}{,} \PY{n+nb+bp}{None}
    \PY{c}{\PYZsh{} we base the score on the previous runs (alpha-beta window)}
    \PY{n}{score} \PY{o}{=} \PY{n}{alpha} \PY{k}{if} \PY{n}{maximize} \PY{k}{else} \PY{n}{beta}
    \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n+nb+bp}{None}
    \PY{k}{for} \PY{n}{child}\PY{p}{,} \PY{n}{move} \PY{o+ow}{in} \PY{n}{board}\PY{o}{.}\PY{n}{children}\PY{p}{(}\PY{n}{is\PYZus{}computer}\PY{p}{)}\PY{p}{:}
        \PY{c}{\PYZsh{} find a new local solution}
        \PY{n}{local}\PY{p}{,} \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{alphabeta}\PY{p}{(}\PY{n}{child}\PY{p}{,} \PY{n}{level} \PY{o}{-} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} 
                \PY{o+ow}{not} \PY{n}{maximize}\PY{p}{,} \PY{o+ow}{not} \PY{n}{is\PYZus{}computer}\PY{p}{)}
        \PY{c}{\PYZsh{} Update the score when a better local solution is found}
        \PY{k}{if} \PY{p}{(}\PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZlt{}} \PY{n}{local}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{o+ow}{not} \PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZgt{}} \PY{n}{local}\PY{p}{)}\PY{p}{:}
            \PY{n}{score} \PY{o}{=} \PY{n}{local}
            \PY{n}{best\PYZus{}move} \PY{o}{=} \PY{n}{move}
        \PY{c}{\PYZsh{} Update alpha or beta (this narrows the alpha-beta window)}
        \PY{k}{if} \PY{n}{maximize}\PY{p}{:}
            \PY{n}{alpha} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{score}\PY{p}{,} \PY{n}{alpha}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{beta} \PY{o}{=} \PY{n+nb}{min}\PY{p}{(}\PY{n}{score}\PY{p}{,} \PY{n}{beta}\PY{p}{)}
        \PY{c}{\PYZsh{} If we fall outside the alpha-beta window, return.}
        \PY{k}{if} \PY{p}{(}\PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n}{beta}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{o+ow}{not} \PY{n}{maximize} \PY{o+ow}{and} \PY{n}{score} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{alpha}\PY{p}{)}\PY{p}{:}
            \PY{k}{break}
    \PY{k}{return} \PY{n}{score}\PY{p}{,} \PY{n}{best\PYZus{}move}
\end{Verbatim}
\newpage
\subsection{TBID* (Time Bound Iterative Deepening)}

\textit{Iterative Deepening} es una técnica donde se ejecuta varias tiradas de un algoritmo con un aumento progresivo en algún parámetro (profundidad, en el caso de Minimax) mientras haya tiempo disponible. Se almacena sólo la solución de la ejecución completa con mayor profundidad.

Dado que el tiempo de ejecución de Minimax varía según el tablero y la profundidad, \textit{Iterative Deepening} provee un marco estable temporal a expensas de estados explorados.

\section{Problemas encontrados y decisiones tomadas}
\subsection{Uso eficiente de memoria}
  Inicialmente cuando se desarrollaron las clases del juego, se notó que consumían memoria demás.
  Eso se vió demostrado ya que el algoritmo propuesto para minimax no podía llegar hasta el nivel 5.
  A continuación se detallan los puntos críticos en donde se tuvo que repensar la implementación.

  \subsection{Clase Board}
    En un principio, la forma utilizada para representar el board fue utilizando un array de $Tile$, del cual heredaban $EmptyTile$ y $BlobTile$.
    Es decir, que la cantidad de referencias de cada tablero era constante.
    Por cada tablero se guardaban 64 $(8 * 8)$ referencias a algún $Tile$.  A la vez, cada $BlobTile$ contenía una referencia a un $Player$.

    Para iterar facilmente por los tiles de un Player y obtener sus jugadas posibles se contó con un $HashMap<Player, ArrayList<Point>>$, y un método para acceder a esos  puntos en donde se encontraban los tiles de cada jugador. Lo cual se descartó para hacer uso más eficiente de la memoria.

    Al eliminar el mapa que referenciaba jugador con sus tiles, se decidió implementar el Board cómo un array primitivo de Player, y un método para convertir de Point al indice de ese array.
    En este caso se hizo un cambio que consume menos memoria al haber menos referencias y objetos en tiempo de ejecucón, aunque es cierto que esa solución hace que haya que calcular más en tiempo de ejecución.

    El cambio más radical en cuanto a cantidad de memoria consumida, se logró implementando un iterador de Board para ser utilizado al generar los tableros con
    las jugadas posibles a partir de cierto Board.

  \subsection{Clase Point}
    La implementación de esta clase fue variando a lo largo del desarrollo del proyecto. En una primera instancia se utilizo la clase $Point$ que provee Java.
    Al ver que estabamos desperdiciando memoria utilizando muchos objetos $Point$ con los mismos valores $(x, y)$, se decidió implementar una clase $Point$ propia.
    La clase contaba con un método de clase $getInstance(int, int)$, si el punto ya estaba creado se devolvía una referencia e él. Sino, se creaba un punto nuevo.
    La implementación de $getInstance()$ se descartó después de haber implementado un iterador en la clase Board, ya que los $Point$ dejaron de ser tantos en memoria.

    Esta clase, ya no sería de de dos coordenads $double$, sino que de $int$. Los beneficios fueron altos ya que además de ocupar menos memoria, no se debía castear de $double$ a $int$ para acceder al array.


\section{Comparaciones y pruebas}


Se probó con dos tableros aleatorios distintos el tiempo de ejecución para las cuatro posibles combinaciones de \textit{solvers}.

\subsection{ABPMinimax}
El tablero 1:
\begin{verbatim}
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| c |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c | c |   |   |   |   |
+---+---+---+---+---+---+---+---+
| h | c |   |   |   |   |   | c |
+---+---+---+---+---+---+---+---+
|   |   | c | c | c |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\begin{tabular}{|c|c|c|c|c|}
\hline
Tablero & Jugador & Profundidad & Tiempo de Ejecución & Estados Explorados \\
\hline
\hline
1&2&1&6ms&147\\
\hline
1&2&2&17ms&403\\
\hline
1&2&3&223ms&53298\\
\hline
1&2&4&878ms&119559\\
\hline
1&2&5&7037ms&9276453\\
\hline
1&2&6&31707ms&19059529\\
\hline
\end{tabular}

\newpage
\subsection{Level Minimax}

El tablero 1:
\begin{verbatim}
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| c |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c | c |   |   |   |   |
+---+---+---+---+---+---+---+---+
| h | c |   |   |   |   |   | c |
+---+---+---+---+---+---+---+---+
|   |   | c | c | c |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\begin{tabular}{|c|c|c|c|c|}
\hline
Tablero & Jugador & Profundidad & Tiempo de Ejecución & Estados Explorados \\
\hline
\hline
1&2&1&14ms&147\\
\hline
1&2&2&41ms&1405\\
\hline
1&2&3&736ms&152930\\
\hline
1&2&4&8474ms&5495678\\
\hline
\end{tabular}

Nota: Level Minimax tiene un bug por el cual el nivel par no es correctamente reportado (min no suma correctamente la variable level). Los números de nivel han sido ajustados.

\newpage
\subsection{TBIDABPMinimax}
El tablero 1:
\begin{verbatim}
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| c |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c | c |   |   |   |   |
+---+---+---+---+---+---+---+---+
| h | c |   |   |   |   |   | c |
+---+---+---+---+---+---+---+---+
|   |   | c | c | c |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\begin{tabular}{|c|c|c|c|c|}
\hline
Tablero & Jugador & Profundidad & Tiempo de Ejecución & Estados Explorados \\
\hline
\hline
1&2&3&1001ms&53848\\
\hline
1&2&4&2000ms&173407\\
\hline
1&2&4&4001ms&173407\\
\hline
1&2&4&8002ms&173407\\
\hline
1&2&5&16000ms&9449860\\
\hline
1&2&5&32001ms&9449860\\
\hline
\end{tabular}

Nota: Las implementaciones de \textit{TBID} no tienen en cuenta los estados explorados en las iteraciones que no fueron completadas, ya que no afectan al resultado del algoritmo.

\newpage
\subsection{TBIDLMinimax}
El tablero 1:
\begin{verbatim}
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| c |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | c | c |   |   |   |   |
+---+---+---+---+---+---+---+---+
| h | c |   |   |   |   |   | c |
+---+---+---+---+---+---+---+---+
|   |   | c | c | c |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\begin{tabular}{|c|c|c|c|c|}
\hline
Tablero & Jugador & Profundidad & Tiempo de Ejecución & Estados Explorados \\
\hline
\hline
1&2&3&1001ms&154482\\
\hline
1&2&3&2000ms&154482\\
\hline
1&2&3&4000ms&154482\\
\hline
1&2&3&8000ms&154482\\
\hline
1&2&3&16001ms&154482\\
\hline
\end{tabular}

Nota: Las implementaciones de \textit{TBID} no tienen en cuenta los estados explorados en las iteraciones que no fueron completadas, ya que no afectan al resultado del algoritmo.

\newpage
\section{Implementación}
\subsection{Chain}
Dado el uso extensivo de iteradores en el código, se sucitó la necesidad de una forma de concatenarlos. \texttt{Chain} se planteó como un \texttt{Iterable<E>} para un conjunto de \texttt{Iterable<E>}, que retornara un \texttt{Iterator<E>} con la concatenación de los iteradores de la lista de iterables.

Está basada en la función \texttt{chain()} de \texttt{itertools} en la librería estándar de Python.
 
\subsection{Paquete \texttt{optparse}}
El parseo de la línea de comandos en Java resultó difícil de encarar mediante el uso crudo de \texttt{String[] args}. Se decidió crear un paquete con una clase \texttt{OptionParser} que fuera un contenedor de objetos \texttt{Option}, quienes fueron diseñados para realizar el parseo localmente.

Dos subclases retornan distintos comportamientos para distintos tipos de opciones: \texttt{FlagOption} parsea opciones sin aridad, mientras que \texttt{ValuedOption} parsea opciones de ariedad arbitraria.
\section{Conclusiones}


De las observaciones de los datos se puede destacar que:
\begin{itemize}
\item La heurística de Poda Alfa-Beta es efectiva y reduce el tiempo de ejecución y espacio en memoria (este último no medido en \textit{benchmarks}) necesarios, mientras que la solución parcial sigue siendo equivalente.
\item La familia de algoritmos \textit{TBID} logra un mejor desempeño para ciertos tableros (dependiendo de la cantidad de movimientos válidos para ambos jugadores), ya que la cantidad de movimientos posibles no es constante. Puede explorar más niveles en partidas cercanas a ser finales.
\item El uso de iteradores y el uso del propio stack de la JVM mejora sustancialmente el desempeño y vale por el tiempo invertido en utilizar estas técnicas. Se desaconseja el uso de listas y mapas para código que es accedido regularmente (\textit{hotspots}). 
\end{itemize}

\newpage
\section{Anexo}
\subsection{Ejemplo de implementación del Solver en Python}
Para cruzar datos con el código en Java y para generar los tableros al azar se implementó un script de Python que validara los movimientos. El mismo se encuentra en: https://gist.github.com/4018933

\subsection{Implementación alternativa del núcleo del Solver}

Se consideró una tercera implementación de \textit{Solvers}, basados en \textit{TBID} y particionamiento horizontal, en el cual levantara tantos \textit{workers} como núcleos disponibles en el equipo, cada uno con un nivel distinto. Cuando un \textit{terminara}, éste recibiría el siguiente nivel del grupo.

En teoría, cada \textit{worker} se ejecutaría en un núcleo distinto con distintos niveles. Por lo tanto, en una máquina de 8 núcleos, podría explorar desde el nivel 1 a 8 y lograr una profundidad igual o mayor que \textit{TBID} para el mismo tiempo, ya que no arrastraría el tiempo de ejecución de niveles anteriores (para los primeros 8 niveles).

Esta solución se descartó dado que la complejidad inherente del mismo, si bien no muy distinta a la de \textit{TBID}, no traía mejoras considerables fuera de los primeros pasos.

\begin{thebibliography}{9}
  % type bibliography here
  \bibitem[BBS]{bbs} \emph{A framework for the unification of the behavioral sciences}, Herbert Gintis, Behavioral and Brain Sciences (2007) 30:1-61

  \bibitem[RAM]{ram} Chen, H.-C., Friedman, J. W. \& Thisse, J.-F. (1997) Boundedly rational Nash
equilibrium: A probablistic choice approach. Games and Economic Behavior
18:32– 54.

  \bibitem[OSB]{osb} Osborne, Martin J., and Ariel Rubinstein. A Course in Game Theory. Cambridge, MA: MIT, 1994. Print.

  \bibitem[MIC]{mic} Bowles, Samuel (2004). Microeconomics: Behavior, Institutions, and Evolution. Princeton University Press. pp. 33–36. ISBN 0-691-09163-3.
\end{thebibliography}
\end{document}
